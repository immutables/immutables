# Criteria Adapter for SQL databases.

**Note:** _This module is highly_ ***experimental*** _and is subject to change in the future.
The underlying implementation and APIs are likely to change in the future. Use discretion when using
this module for anything more than experimentation._

This is a minimal implementation of criteria support for SQL databases, supporting the basic
CRUD operations of entities persisted in single tables. It is intended to be a lightweight
alternative to other ORMs but does not compete directly with them or support all the features of SQL databases.
There are no dependencies in this implementation beyond basic JDBC support.

## General approach

The approach is a pretty straightforward mapping from Criteria APIs to the underlying
JDBC concepts. A Criteria operation is converted into a SQL command (in `commands`) which
call to the SQL compiler to generate a SQL statement corresponding to the operation, and
which also sets up mapping from supplied data to the underlying named parameters. When
statements are executed, the parameters are converted, then bound into position in
within `FluentStatement`. Inserts and updates of entities are done in a batch.

### Annotations

There are some SQL-specific annotations supported, which help with mapping to the
underlying tables.

* `SQL.Table` - specify the target table for an entity
* `SQL.Column` - map a property to a column and optionally a column type

### Type conversion

Object and properties are converted to underlying SQL data types using classes
in the `conversion` package. At the lower level rows are mapped to objects by calling to
the associated `RowMapper` which is registered in `RowMappers`. A `RowMapper` class and a `Setup`
class are generated for each class annotated with `SQL.Table` - for example a `Note` class would
generate a `SqlNoteSetup` class and a `SqlNoteRowMapper` class - the latter of which will be registered
into `RowMappers` when the setup class us called to get a `Backend`. Currently, this assumes a standard
immutable class builder being generated, which may or may not work if `Style` is used extensively.
Type conversion happens my looking up registered converters in `TypeConverters`. All
conversion lookups support registration of custom conversions.

#### Generic Jackson conversion
A default `RowMapper` is generated however you can also use `Jackson` to convert
from a row to objects, with the Jackson annotations having an impact on the mapping (`JsonSerializeAs` etc).
As an example, the following could be used to generate a RowMapper used in a custom setup.

```java
static <T> RowMapper<T> newRowMapper(final SqlTypeMetadata metadata) {
  return row -> {
    final Map<String, Object> data = new HashMap<>();
    final ResultSetMetaData rm = row.getMetaData();
    for (int i = 1; i <= rm.getColumnCount(); ++i) {
      final String name = rm.getColumnName(i).toLowerCase(Locale.ROOT);
      final SqlPropertyMetadata property = metadata.columns().get(name);
      if (property != null) {
        data.put(property.name(), TypeConverters.convert(property.mapping().type(), property.type(),
                 property.mapping().fetcher().apply(row, rm.getColumnName(i))));
      }
    }
    return (T) MAPPER.convertValue(data, metadata.type());
  };
}
```

## Limitations

- Watch,GetByKey,DeleteByKey,Upsert are not implemented
- Handling of autogenerated keys and returning keys is not supported
- Joins, sub-graphs etc. are not supported.
- Projections, aggregations, groupby etc are not supported

---
**Note:** _This module is highly_ ***experimental*** _and is subject to change in the future._
