[template public generate]
  [for type in values.values]
    [if type.constitution.hasTopLevelImmutable]
[-- Top level immutable type --]
[output.java type.package type.typeImmutable.simple]
[generateImmutable type true]
[/output.java]
    [/if]
    [if type.constitution.hasTopLevelBuilder]
[-- Top level builder --]
[output.java type.package type.typeBuilderImpl.simple]
[generateBuilder type true]
[/output.java]
    [/if]
    [if type.constitution.hasEnclosingNonvalue]
[-- Enclosing non-value type --]
[output.java type.package type.typeEnclosing.simple]
[type.sourceHeader]
[generateEnclosing type]
[/output.java]
    [/if]
  [/for]
[/template]

[template annotationsWhenTopLevel Type type Boolean is]
[if is]
[if type.generateSuppressAllWarnings]
@SuppressWarnings([if type.hasDeprecatedAttributes]{"all", "deprecation"}[else]"all"[/if])
[else if type.hasDeprecatedAttributes]
@SuppressWarnings("deprecation")
[/if]
[if classpath.available 'javax.annotation.ParametersAreNonnullByDefault']
@javax.annotation.ParametersAreNonnullByDefault
[/if]
[if classpath.available 'javax.annotation.Generated']
@javax.annotation.Generated({"Immutables.generator", "[type.typeAbstract.relative]"})
[/if]
[/if]
[/template]

[template packageWhenTopLevel Type type Boolean is]
[if is]
[type.sourceHeader]
  [if type.package]
package [type.package];
  [/if]

import java.lang.String;
  [for starImport in type.requiredSourceStarImports]
import [starImport];
  [/for]
[/if]
[/template]

[template generateEnclosing Type type]
[packageWhenTopLevel type true]

/**
 * {@code [type.typeEnclosing.simple]} contains immutable implementation classes generated from
 * abstract value types defined as nested inside {@link [type.typeAbstract.relative]}.
[for v in type.nested]
 * @see [v.typeValue.relative]
[/for]
 */
[annotationsWhenTopLevel type true]
[type.typeEnclosing.access]final class [type.typeEnclosing.simple] {
  private [type.typeEnclosing.simple]() {}
[for v in type.nested]
  [generateImmutable v false]
  [if v.constitution.isOutsideBuilder]
  [generateBuilder v false]
  [/if]
  [forwardingEnclosingFactoryMethods v]
[/for]
[if type.generateJdkOnly]
  [objectsUtility type]
[/if]
[if type.generateJdkOnly and type.useCollectionUtility]
  [collectionUtility type]
[/if]
}
[/template]

[template generateImmutable Type type Boolean topLevel]
[packageWhenTopLevel type topLevel]

[for setters = type.settableAttributes]
/**
 * Immutable implementation of {@link [type.typeAbstract.relative]}.
 * <p>
 [if type.useBuilder]
 * Use builder to create immutable instances:
 * {@code [type.factoryBuilder.relative]()}.
 [/if]
 [if type.useConstructor]
 * Use static factory method to create immutable instances:
 * {@code [type.factoryOf.relative]()}.
 [/if]
 [if type.useSingleton]
 * Use static factory method to get default singleton instance:
 * {@code [type.factoryInstance.relative]()}.
 [/if]
 */
[annotationsWhenTopLevel type topLevel]
[if classpath.available 'javax.annotation.concurrent.Immutable']
@javax.annotation.concurrent.Immutable
[/if]
[for a in type.passedAnnotations]
[a]
[/for]
[type.typeImmutable.access][if not topLevel]static [/if]final [output.linesShortable]class [type.typeImmutable.simple]
    [extendsImplements type][/output.linesShortable]
[if type.annotationType]
  [defaultAnnotationValues type]
[/if]
[generateImmutableMembers type]
[generateLazyValues type]
[generateSingletonInstance type]
[generateConstructionAndInterning type]
  [generateImmutableCopyOf type]
  [generateSerialization type]
[if type.useBuilder and (not type.constitution.isOutsideBuilder)]
  [if not type.factoryBuilder.isNew]

  /**
   * Creates builder for {@link [type.typeValue] [type.typeValue.simple]}.
   * @return new [type.typeValue.simple] builder
   */
  [type.typeBuilderImpl.access]static [type.typeBuilderImpl.relative] [type.factoryBuilder.applied]() {
    return new [type.typeBuilderImpl.relative]();
  }
  [/if]
  [generateBuilder type false]
[/if]
[for v in type.nested]
  [generateImmutable v false]
[/for]
[if topLevel and type.generateJdkOnly]
  [objectsUtility type]
[/if]
[if topLevel and (type.generateJdkOnly and type.useCollectionUtility)]
  [collectionUtility type]
[/if]
}
[/for]
[/template]

[template extendsImplements Type type]
[if type.implementing]
implements [type.typeAbstract][if type.serial.shouldImplement], java.io.Serializable[/if] {
[else]
extends [type.typeAbstract][if not type.serial.shouldImplement] {[else]
implements java.io.Serializable {[/if]
[/if]
[/template]

[template generateSerialization Type type]
[if type.serial.simple]
  [for serialVersion = type.serialVersionUID]
    [if serialVersion]

private static final long serialVersionUID = [literal serialVersion];
    [/if]
  [/for]
  [if type.useSimpleReadResolve]

private Object readResolve() throws java.io.ObjectStreamException {
[if type.useSingletonOnly][-- don't care about validation here, just substitute --]
  return INSTANCE;
[else]
  return [validated type false]this[/validated];
[/if]
}
  [/if]
[/if]
[if type.serial.structural]

/**
 * Serialized form captures structural content of the value object.
 * To be able to reconstruct with a data migration capability. Using optional, nullable
 * and flexible handling of collection attributes.
 */
private static class SerialForm implements java.io.Serializable {
[for serialVersion = type.serialVersionUID, String arr = '[]', String arri = '[i]']
  private static final long serialVersionUID = [if serialVersion][literal serialVersion][else]0L[/if];
  private final String['[]'] names;
  private final Object['[]'] values;
  SerialForm([type.typeImmutable] instance) {
[if type.useSingletonOnly]
    this.names = new String['[]']{};
    this.values = new Object['[]']{};
  }

  Object readResolve() {
    return INSTANCE;
  }
[else]
    java.util.List<String> names = new java.util.ArrayList<String>([size type.settableAttributes]);
    java.util.List<Object> values = new java.util.ArrayList<Object>([size type.settableAttributes]);
  [for v in type.settableAttributes]
    [if v.collectionType]
    if (!instance.[v.names.get]().isEmpty()) {
      names.add("[v.name]");
      values.add(instance.[v.names.get]().toArray());
    }
    [else if v.mapType]
    if (!instance.[v.names.get]().isEmpty()) {
      names.add("[v.name]");
      values.add(toArray(instance.[v.names.get]().[if v.multimapType]entries[else]entrySet[/if]()));
    }
    [else if v.optionalType]
    if (instance.[v.names.get]().isPresent()) {
      names.add("[v.name]");
      values.add(instance.[v.names.get]().[optionalGet v]);
    }
    [else if v.nullable]
    if (instance.[v.names.get]() != null) {
      names.add("[v.name]");
      values.add(instance.[v.names.get]());
    }
    [else]
    names.add("[v.name]");
    values.add(instance.[v.names.get]());
    [/if]
  [/for]
    this.names = names.toArray(new String['[']names.size()[']']);
    this.values = values.toArray();
  }

  Object readResolve() {
[if type.useBuilder]
    [type.typeBuilder] builder = [type.factoryBuilder.relative]();

    for (int i = 0; i < names.length; i++) {
      switch (names['[i]']) {
    [for v in type.settableAttributes]
      case "[v.name]": {
      [if v.collectionType]
        for (Object e : toArray(values[arri])) {
          builder.[v.names.add](([v.wrappedElementType]) e);
        }
      [else if v.mapType]
        [atNullable]Object[arr] entries = (Object[arr]) values[arri];
        if (entries != null) {
          for (int j = 0; j < entries.length; j += 2) {
          [for String j = '[j]', String j1 = '[j + 1]']
            builder.[v.names.put](([v.wrappedElementType]) entries[j], ([v.wrappedSecondaryElementType]) entries[j1]);
          [/for]
          }
        }
      [else if v.optionalType]
        if (values[arri] != null) {
          builder.[v.names.init](([v.wrappedElementType]) values[arri]);
        }
      [else if v.nullable]
        if (values[arri] != null) {
          builder.[v.names.init](([v.type]) values[arri]);
        }
      [else if v.arrayType]
        builder.[v.names.init](([v.type]) values[arri]);
      [else]
        builder.[v.names.init](([v.wrapperType]) toSingle("[v.name]", values[arri]));
      [/if]
      } break;
    [/for]
      default:
      }
    }
    return builder.[type.names.build]();
[else]
  [for constructables = type.constructableAttributes]
    [for v in constructables]
      [if v.collectionType or v.mapType]
    [createBuilderForCollection type v][v.name]Builder[/createBuilderForCollection]
      [else if v.optionalType]
    [v.type] [v.name]Value = [optionalEmpty v];
      [else]
    [atNullable][v.wrapperType] [v.name]Value = null;
      [/if]
    [/for]

    for (int i = 0; i < names.length; i++) {
      switch (names['[i]']) {
    [for v in constructables]
      case "[v.name]": {
      [if v.collectionType]
        for (Object e : toArray(values[arri])) {
          [v.name]Builder.add(([v.wrappedElementType]) e);
        }
      [else if v.mapType]
        Object[arr] entries = (Object[arr]) values[arri];
        if (entries != null) {
          for (int j = 0; j < entries.length; j += 2) {
          [for String j = '[j]', String j1 = '[j + 1]']
            [v.name]Builder.put(([v.wrappedElementType]) entries[j], ([v.wrappedSecondaryElementType]) entries[j1]);
          [/for]
          }
        }
      [else if v.optionalType]
        if (values[arri] != null) {
          [v.name]Value = [v.rawType].of(([v.wrappedElementType]) values[arri]);
        }
      [else if v.nullable or v.arrayType]
        [v.name]Value = ([v.wrapperType]) values[arri];
      [else]
        [v.name]Value = ([v.wrapperType]) toSingle("[v.name]", values[arri]);
      [/if]
      } break;
    [/for]
      default:
      }
    }
  [if type.useConstructor]
    [type.typeValue.relative] instance = [type.factoryOf.relative]([output.linesShortable][for v in type.constructorArguments][if not for.first],[/if]
        [if v.collectionType or v.mapType][createBuiltCollection type v][v.name]Builder[/createBuiltCollection][else][v.name]Value[/if][/for]);[/output.linesShortable]
  [else if type.useSingleton]
    [type.typeValue.relative] instance = [type.factoryInstance.relative]();
  [else]
    [output.error]Cannot generate code when there are no builder, constructor or singleton available[/output.error]
  [/if]
    [for o in type.withSettableAfterConstruction]
      [if o.collectionType or o.mapType]
    instance = instance.[o.names.with]([createBuiltCollection type o][o.name]Builder[/createBuiltCollection]);
      [else]
    if ([o.name]Value != null) {
      instance = instance.[o.names.with]([o.name]Value);
    }
      [/if]
    [/for]
    return instance;
  [/for]
[/if]
  }

  private static Object toSingle(String attribute, Object value) {
    if (value instanceof Object[arr]) {
      Object[arr] elements = (Object[arr]) value;
      if (elements.length == 1) {
        return elements['[0]'];
      }
      throw new [type.throwForInvalidImmutableState]("Cannot decide scalar value for attribute '"
          + attribute + "' from array of length " + elements.length);
    }
    return value;
  }
  [if type.hasSettableCollection]

  private static Object[arr] toArray([atNullable] Object value) {
    if (value == null) {
      return new Object[arr]{};
    }
    if (value instanceof Object[arr]) {
      return (Object[arr]) value;
    }
    return new Object[arr]{ value };
  }
  [/if]
  [if type.hasSettableMapping]

  private static Object['[]'] toArray(java.util.Collection<? extends java.util.Map.Entry<?, ?>> entries) {
    Object['[]'] data = new Object['[']entries.size() * 2[']'];
    int p = 0;
    for (java.util.Map.Entry<?, ?> e : entries) {
      data['[']p++[']'] = e.getKey();
      data['[']p++[']'] = e.getValue();
    }
    return data;
  }
  [/if]
[/if]
[/for]
}

private Object writeReplace() {
  return new SerialForm(this);
}
[/if]
[/template]

[template generateConstructionAndInterning Type type]
[if type.useInterned or type.generateOrdinalValue]
  [if not type.useSingletonOnly]

  private static class InternProxy {
    final [type.typeImmutable.simple] instance;

    InternProxy([type.typeImmutable.simple] instance) {
      this.instance = instance;
    }

    @Override
    public boolean equals([atNullable]Object another) {
      return instance.equalTo(((InternProxy) another).instance);
    }

    @Override
    public int hashCode() {
      return instance.hashCode();
    }
  }
  [/if]
[/if]
[if type.generateOrdinalValue]

  /**
   * Copy constructor used for interning of objects implementing
   * {@link org.immutables.ordinal.OrdinalValue}
   */
  private [type.typeImmutable.simple]([type.typeImmutable.simple] instance, int ordinal) {
  [for v in type.implementedAttributes]
    this.[v.name] = instance.[v.name];
  [/for]
  [if type.usePrehashed]
    this.hashCode = instance.hashCode;
  [/if]
    this.domain = instance.domain;
    this.ordinal = ordinal;
  }

  /**
   * Instances of {@code [type.name]} will be interned and registered with the domain.
   */
  public static final class Domain
      extends org.immutables.ordinal.InterningOrdinalDomain<InternProxy, [type.typeAbstract]> {

    private static final Domain INSTANCE = new Domain();

    /** Construct ordinal domain of [type.name] values. */
    public Domain() {}

    protected [type.typeAbstract] extractValue(InternProxy proxy, int ordinal) {
      return new [type.typeImmutable.simple](proxy.instance, ordinal);
    }

    @Override
    public String toString() {
      if (this == INSTANCE) return "[type.typeImmutable.simple].Domain.get()";
      return [type.typeMoreObjects].toStringHelper("[type.typeImmutable.simple].Domain")
          .add("length", length())
          .toString();
    }

    /**
     * Gets static singleton instance of {@link OrdinalDomain}.
     * All instances that was not build with specified domain will be bound to static domain.
     * @return ordinal domain of all instances
     */
    public static Domain get() {
      return INSTANCE;
    }
  }

  @Override
  public org.immutables.ordinal.OrdinalDomain<[type.typeAbstract]> domain() {
    return domain;
  }
[else if type.useSingletonOnly][-- deliberately left empty --]
[else if type.useInterned]

  [if type.generateJdkOnly]
  private static final java.util.concurrent.ConcurrentHashMap<InternProxy, [type.typeImmutable.simple]> INTERNER =
      new java.util.concurrent.ConcurrentHashMap<>();
  [else]
  private static final [guava].collect.Interner<InternProxy> INTERNER = [guava].collect.Interners.newStrongInterner();
  [/if]
[/if]
[if type.useConstructor]
  [if type.requiresAlternativeStrictConstructor]

  /**
   * Construct new immutable {@code [type.name]} instance.
[for v in type.constructorArguments]
   * @param [v.name] value for {@code [v.name]}
[/for]
   * @return immutable [type.name] instance
   */
  public static [type.typeValue] [type.names.of]([for v in type.constructorArguments][if not for.first], [/if][v.atNullability][v.type] [v.name][/for]) {
    return [type.names.of]([for v in type.constructorArguments][if not for.first], [/if][if v.requiresAlternativeStrictConstructor]([constructorAcceptType v]) [/if][v.name][/for]);
  }
  [/if]

  /**
   * Construct new immutable {@code [type.name]} instance.
[for v in type.constructorArguments]
   * @param [v.name] value for {@code [v.name]}
[/for]
   * @return immutable [type.name] instance
   */
  public static [type.typeValue] [type.names.of]([for v in type.constructorArguments][if not for.first], [/if][v.atNullability][constructorAcceptType v] [v.name][/for]) {
    return [validated type false]new [type.typeImmutable.simple]([for v in type.constructorArguments][if not for.first], [/if][v.name][/for])[/validated];
  }
[/if]
[if type.useValidation]

  private static [type.typeImmutable.simple] validate([type.typeImmutable.simple] instance) {
[if type.validationMethodName]
    instance.[type.validationMethodName]();
[/if]
[if type.useSingletonOnly]
    return INSTANCE != null ? INSTANCE : instance;[-- may be null during initialization --]
[else if type.generateOrdinalValue]
    return ([type.typeImmutable.simple]) instance.domain.internOrdinal(new InternProxy(instance));
[else if type.useInterned]
  [if type.generateJdkOnly]
    [atNullable][type.typeImmutable.simple] interned = INTERNER.putIfAbsent(new InternProxy(instance), instance);
    return interned != null ? interned : instance;
  [else]
    return INTERNER.intern(new InternProxy(instance)).instance;
  [/if]
[else if type.useSingleton]
    return INSTANCE != null && INSTANCE.equalTo(instance) ? INSTANCE : instance;[-- may be null during initialization --]
[else]
    return instance;
[/if]
  }
[/if]
[/template]

[template generateSingletonInstance Type type]
[if type.useSingleton]

  private static final [type.typeImmutable.simple] INSTANCE = [validated type false]new [type.typeImmutable.simple]()[/validated];

  /**
   * Returns default immutable singleton value of {@code [type.name]}
   * @return immutable instance of [type.name]
   */
  [type.typeImmutable.access]static [type.typeValue.relative] [type.names.instance]() {
    return INSTANCE;
  }
[/if]
[/template]

[template generateImmutableCopyOf Type type]
[if type.useCopyConstructor and (not type.constitution.isImplementationHidden)]

/**
 * Creates immutable copy of {@link [type.typeAbstract.relative]}.
 * Uses accessors to get values to initialize immutable instance.
 * If an instance is already immutable, it is returned as is.
 * @param instance instance to copy
 * @return copied immutable [type.name] instance
 */
[type.typeImmutable.access]static [type.typeValue.relative] [type.factoryCopyOf.applied]([if type.constitution.isImplementationPrimary][type.typeImmutable.relative][else][type.typeAbstract.relative][/if] instance) {
  if (instance instanceof [type.typeImmutable.relative]) {
    return ([type.typeImmutable.simple]) instance;
  }
[if type.useBuilder]
  return [type.factoryBuilder.relative]()
    [if type.generateBuilderFrom]
      .[type.names.from](instance)
    [else]
      [for v in type.settableAttributes]
        [if v.collectionType]
      .[v.names.addAll](instance.[v.names.get]())
        [else if v.mapType]
      .[v.names.putAll](instance.[v.names.get]())
        [else]
      .[v.names.init](instance.[v.names.get]())
        [/if]
      [/for]
    [/if]
      .[type.names.build]();
[else]
  return [type.factoryOf.relative]([for v in type.constructorArguments][if not for.first], [/if]instance.[v.names.get]()[/for])[for
          o in type.withSettableAfterConstruction]
      .[o.names.with](instance.[o.names.get]())[/for];
[/if]
}
[/if]
[/template]

[template generateLazyValues Type type]
[for lz = type.lazyAttributes]
  [if lz]

  [for LongPositions positions = longsFor lz]
  [for l in positions.longs]
  private [if type.serial.simple]transient [/if]volatile long lazyInitBitmap[emptyIfZero l.index];
  [/for]
  [for l in lz, BitPosition pos = positions l]
  [let maskConstantName][toConstant l.name]_LAZY_INIT_BIT[/let]
  [let bitmapFieldName]lazyInitBitmap[emptyIfZero pos.index][/let]

  private static final long [maskConstantName] = [literal.hex pos.mask];

  private [if type.serial.simple]transient [/if][l.type] [l.name];

  /**
   * {@inheritDoc}
   * <p>
   * Returns lazily initialized value of [sourceDocRef type l] attribute.
   * Initialized once and only once and stored for subsequent access with proper synchronization.
   * @return lazily initialized value of {@code l.name}
   */
  @Override
  public [l.type] [l.names.get]() {
    if (([bitmapFieldName] & [maskConstantName]) == 0) {
      synchronized (this) {
        if (([bitmapFieldName] & [maskConstantName]) == 0) {
            [if l.primitive or l.nullable]
          this.[l.name] = [invokeSuper l].[l.names.get]();
            [else]
          this.[l.name] = [requireNonNull type]([invokeSuper l].[l.names.get]());
            [/if]
          [bitmapFieldName] |= [maskConstantName];
        }
      }
    }
    return [l.name];
  }
  [/for]
  [/for][/if]
[/for]
[/template]

[template generateBuilder Type type Boolean topLevel]
[packageWhenTopLevel type topLevel]
[for setters = type.settableAttributes,
     getters = type.implementedAttributes,
     mandatories = type.mandatoryAttributes,
     nondefaults = type.requiresTrackedIsSetNonMandatoryAttributes,
     LongPositions positions = longsFor mandatories,
     LongPositions nondefaultsPositions = longsFor nondefaults]

/**
[if type.kind.isFactory]
 * {@code [type.typeBuilderImpl.simple]} collects parameters and invokes static factory method:
 * {@code [type.factoryOf](..)}.
 * Call {@link #[type.names.build]()} method to get result of type {@code [type.typeValue]}.
[else]
 * Builds instances of {@link [type.typeValue] [type.typeValue.simple]}.
 * Initialize attributes and then invoke {@link #[type.names.build]()} method to create
 * immutable instance.
[/if]
 * <p><em>{@code [type.typeBuilderImpl.simple]} is not thread safe and generally should not be stored in field or collection,
 * but used immediately to create instances.</em>
 */
[annotationsWhenTopLevel type topLevel]
[if classpath.available 'javax.annotation.concurrent.NotThreadSafe']
@javax.annotation.concurrent.NotThreadSafe
[/if]
[type.typeBuilderImpl.access][if not topLevel]static [/if][if not type.innerBuilder.isExtending]final [/if]class [type.typeBuilderImpl.simple] [if type.innerBuilder.isSuper]
    [if type.innerBuilder.isInterface]implements[else]extends[/if] [type.typeAbstract].[type.innerBuilder.simpleName] {[else]{[/if]
  [for m in mandatories, BitPosition pos = positions m]
  private static final long INIT_BIT_[toConstant m.name] = [literal.hex pos.mask];
  [/for]
  [for p in nondefaults, BitPosition pos = nondefaultsPositions p]
  private static final long OPT_BIT_[toConstant p.name] = [literal.hex pos.mask];
  [/for]
  [for l in positions.longs]
  private long [disambiguateField type 'initBits'][emptyIfZero l.index] = [literal.hex l.occupation];
  [/for]
  [for l in nondefaultsPositions.longs]
  private long [disambiguateField type 'optBits'][emptyIfZero l.index];
  [/for]
  [if positions.longs or nondefaultsPositions.longs][-- just to separate sections --]

  [/if]
  [for v in setters]
  [defineOrResetBuildingField v true]
  [/for]
  [if type.generateOrdinalValue]
  private Domain domain = Domain.get();
  [/if]
[for Boolean useFactoryMethod = not type.factoryBuilder.isNew]
[if type.kind.isFactory]
  [for parameters = p for p in setters if p.isBuilderParameter]

  [if not useFactoryMethod]
  /**
   * Constructs {@code [type.typeBuilder.simple]} factory builder.
[for p in parameters]
   * @param [p.name] {@code [p.name]} parameter[if p.nullable], can be {@code null}[/if]
[/for]
   */
  [/if]
  [if useFactoryMethod]private [else][type.typeBuilder.access][/if][type.typeBuilder.simple]([for p in parameters][if not for.first], [/if][p.atNullability][constructorAcceptType p] [p.name][/for]) {
    [for v in setters]
      [if v.builderSwitcher]
        [for o in v.builderSwitcherModel.options if o.isDefault]
    this.[v.name] = [v.rawType].[o.constantName];
        [/for]
      [/if]
      [if v.isBuilderParameter]
        [if v.collectionType]
    [v.names.addAll]([v.name]);
        [else if v.mapType]
    [v.names.putAll]([v.name]);
        [else]
    [v.names.init]([v.name]);
        [/if]
      [/if]
    [/for]
  }
    [if useFactoryMethod]

  /**
   * Creates {@code [type.typeBuilder.simple]} factory builder.
[for p in parameters]
   * @param [p.name] {@code [p.name]} parameter[if p.nullable], can be {@code null}[/if]
[/for]
   * @return new builder
   */
  [type.typeBuilder.access]static [type.typeBuilder.simple] [type.factoryBuilder.applied]([for p in parameters][if not for.first], [/if][p.atNullability][constructorAcceptType p] [p.name][/for]) {
    return new [type.typeBuilder.simple]([for p in parameters][if not for.first], [/if][p.name][/for]);
  }
    [/if]
  [/for]
[else if useFactoryMethod]

  private [type.typeBuilderImpl.simple]() {}
  [if type.constitution.isOutsideBuilder]

  /**
   * Creates builder for {@link [type.typeValue] [type.typeValue.simple]}.
   * @return new [type.typeValue.simple] builder
   */
  public static [type.typeBuilderImpl.simple] [type.factoryBuilder.applied]() {
    return new [type.typeBuilderImpl.simple]();
  }
  [/if]
[else if type.innerBuilder.isExtending]

  [type.typeBuilderImpl.simple]() {
    if (!(this instanceof [type.typeBuilder])) {
      throw new UnsupportedOperationException("Use: [type.factoryBuilder.relative]()");
    }
  }
[/if]
[/for]
[if type.generateOrdinalValue]

  /**
   * Specify non-default {@link Domain} for ordinal value.
   * @return {@code this} builder for chained invocation
   */
  public final [builderReturnType type] domain(Domain domain) {
    this.domain = [requireNonNull type](domain);
    [builderReturnThis type]
  }
[/if]
[if type.kind.isValue]
  [if type.generateBuilderFrom]
    [if type.buildFromTypes and type.buildFromTypes.hasManySupertypes]
      [for s in type.buildFromTypes.supertypes]

  /**
   * Fill builder with attribute values from provided {@link [s.type]} instance.
   * @param instance instance to copy values from
   * @return {@code this} builder for chained invocation
   */
  public final [builderReturnType type] [type.names.from]([if type.constitution.isImplementationPrimary and (s.type eq type.typeAbstract.toString)][type.typeImmutable.relative][else][s.type][/if] instance) {
    [requireNonNull type](instance);
    from((Object) instance);
    [builderReturnThis type]
  }
      [/for]

  private void from(Object object) {
[for bs = type.buildFromTypes]
    [for l in bs.positions.longs]
    long bits[emptyIfZero l.index] = 0;
    [/for]
  [for s in bs.supertypes if s.attributes]
    if (object instanceof [s.type]) {
      [s.type] instance = ([s.type]) object;
      [for v in s.attributes, BitPosition pos = bs.positions v.name]
      [if pos]
      if ((bits[emptyIfZero pos.index] & [literal.hex pos.mask]) == 0) {
        [buildFromAttribute v]
        bits[emptyIfZero pos.index] |= [literal.hex pos.mask];
      }
      [else]
      [buildFromAttribute v]
      [/if]
      [/for]
    }
  [/for]
[/for]
  }
    [else]

  /**
   * Fill builder with attribute values from provided {@link [type.typeAbstract.relative]} instance.
   * Regular attribute values will be replaced with ones of an instance.
   * Instance's absent optional values will not replace present values.
  [if type.hasSettableCollection or type.hasSettableMapping]
   * Collection elements and entries will be added, not replaced.
  [/if]
   * @param instance instance to copy values from
   * @return {@code this} builder for chained invocation
   */
  public final [builderReturnType type] [type.names.from]([if type.constitution.isImplementationPrimary][type.typeImmutable.relative][else][type.typeAbstract.relative][/if] instance) {
    [requireNonNull type](instance);
    [for v in setters]
    [buildFromAttribute v]
    [/for]
    [builderReturnThis type]
  }
    [/if]
  [/if]
[/if]
[-- Being called from builder initializer methods --]
[let checkNotIsSet Attribute v]
[if v.containingType.useStrictBuilder]
checkNotIsSet([v.names.isSet](), "[v.name]");
[/if]
[/let]
[-- Being called from builder initializer methods --]
[let nondefaultSetInBuilder Attribute v]
[if v.requiresTrackIsSet][for BitPosition pos = nondefaultsPositions v]
[disambiguateField type 'optBits'][emptyIfZero pos.index] |= OPT_BIT_[toConstant v.name];
[/for][/if]
[/let]
[-- Being called from builder initializer methods --]
[let mandatorySetInBuilder Attribute v]
[if v.mandatory][for BitPosition pos = positions v]
[disambiguateField type 'initBits'][emptyIfZero pos.index] &= ~INIT_BIT_[toConstant v.name];
[/for][/if]
[/let]
  [for v in setters]
  [if v.builderSwitcher]
    [for o in v.builderSwitcherModel.options]

  /**
   * Switches {@code [v.name]} to {@code [o.constantName]}.
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  [if o.isDefault]private[else]public[/if] final [builderReturnType type] [o.switcherName]() {
    [checkNotIsSet v]
    this.[v.name] = [v.rawType].[o.constantName];
    [nondefaultSetInBuilder v]
    [mandatorySetInBuilder v]
    [builderReturnThis type]
  }
    [/for]
  [else if v.collectionType]
    [if not v.isBuilderParameter]

  /**
   * Adds one element to [sourceDocRef type v] [toLower v.rawCollectionType].
   * @param element [v.name] element
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  public final [builderReturnType type] [v.names.add]([v.unwrappedElementType] element) {
    [if v.generateJdkOnly and (not v.primitiveElement)]
    [v.name]Builder.add([requireNonNull type](element));
    [else]
    [v.name]Builder.add(element);
    [/if]
    [builderReturnThis type]
  }

  /**
   * Adds elements to [sourceDocRef type v] [toLower v.rawCollectionType].
   * @param elements array of [v.name] elements
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  [varargsSafety v]
  public final [builderReturnType type] [v.names.add]([v.unwrappedElementType]... elements) {
    [if v.generateJdkOnly]
    for ([v.unwrappedElementType] element : elements) {
      [if v.primitiveElement]
      [v.name]Builder.add(element);
      [else]
      [v.name]Builder.add([requireNonNull type](element));
      [/if]
    }
    [else]
      [if v.wrapArrayToIterable]
    [v.name]Builder.addAll([arrayAsList v 'elements']);
      [else]
    [v.name]Builder.add(elements);
      [/if]
    [/if]
    [builderReturnThis type]
  }
      [if not type.useStrictBuilder]

  /**
   * Sets or replaces all elements for [sourceDocRef type v] [toLower v.rawCollectionType].
   * @param elements iterable of [v.name] elements
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  public final [builderReturnType type] [v.names.init](Iterable<[v.consumedElementType]> elements) {
    [defineOrResetBuildingField v false]
    return [v.names.addAll](elements);
  }
      [/if]
    [/if]

  /**
   * Adds elements to [sourceDocRef type v] [toLower v.rawCollectionType].
   * @param elements iterable of [v.name] elements
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  [builderInitAccess v] final [builderReturnType type] [v.names.addAll](Iterable<[v.consumedElementType]> elements) {
    [if v.generateJdkOnly]
    for ([v.unwrappedElementType] element : elements) {
      [v.name]Builder.add([requireNonNull type](element));
    }
    [else]
    [v.name]Builder.addAll(elements);
    [/if]
    [builderReturnThis type]
  }
  [else if v.optionalType]
    [if not v.isBuilderParameter]

  /**
   * Initializes present value for optional [sourceDocRef type v].
   * @param [v.name] value for [v.name][if v.optionalAcceptNullable], {@code null} is accepted as {@code [optionalEmpty v]}[/if]
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  public final [builderReturnType type] [v.names.init]([atNullableAccept v][v.unwrappedElementType] [v.name]) {
    [checkNotIsSet v]
    this.[v.name] = [optionalOf v]([v.name]);
    [nondefaultSetInBuilder v]
    [builderReturnThis type]
  }
    [/if]

  /**
   * Initializes optional value for [sourceDocRef type v].
   * @param [v.name] value for [v.name]
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  [builderInitAccess v] final [builderReturnType type] [v.names.init]([v.rawType][if not v.jdkSpecializedOptional]<[v.wrappedElementType]>[/if] [v.name]) {
    [checkNotIsSet v]
    this.[v.name] = [requireNonNull type]([v.name]);
    [nondefaultSetInBuilder v]
    [builderReturnThis type]
  }
  [else if v.mapType]
    [for gE = v.consumedElementType, uK = v.unwrappedElementType, wK = v.wrappedElementType, uV = v.unwrappedSecondaryElementType, wV = v.wrappedSecondaryElementType]
      [if v.multimapType]
        [if not v.isBuilderParameter]

  /**
   * Put all mappings from specified key to values for [sourceDocRef type v] [toLower v.mapType]. Nulls are not permitted
   * @param key the key for [v.name]
   * @param values the values for [v.name]
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  public final [builderReturnType type] [v.names.put]([uK] key, [uV]... values) {
    [v.name]Builder.putAll(key, [arrayAsListSecondary v 'values']);
    [builderReturnThis type]
  }

  /**
   * Put all mappings from specified key to values for [sourceDocRef type v] [toLower v.mapType]. Nulls are not permitted
   * @param key the key for [v.name]
   * @param values the values for [v.name]
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  public final [builderReturnType type] [v.names.putAll]([uK] key, Iterable<[wV]> values) {
    [v.name]Builder.putAll(key, values);
    [builderReturnThis type]
  }
        [/if]
      [/if]
        [if not v.isBuilderParameter]

  /**
   * Put one entry to [sourceDocRef type v] map.
   * @param key the key in [v.name] map
   * @param value the associated value in [v.name] map
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  public final [builderReturnType type] [v.names.put]([uK] key, [uV] value) {
    [if v.generateJdkOnly]
    [v.name]Builder.put(
        [requireNonNull type](key, "Key cannot be null"),
        [requireNonNull type](value, "Value cannot be null"));
    [else]
    [v.name]Builder.put(key, value);
    [/if]
    [builderReturnThis type]
  }

  /**
   * Put one entry to [sourceDocRef type v] map. Nulls are not permitted
   * @param entry the key and value entry
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  public final [builderReturnType type] [v.names.put](java.util.Map.Entry<[gE], ? extends [wV]> entry) {
    [if v.generateJdkOnly]
    [v.name]Builder.put(
        [requireNonNull type](entry.getKey(), "Key cannot be null"),
        [requireNonNull type](entry.getValue(), "Value cannot be null"));
    [else]
    [v.name]Builder.put(entry);
    [/if]
    [builderReturnThis type]
  }
          [if not type.useStrictBuilder]

  /**
   * Sets or replaces all mappings from specified map as entries for [sourceDocRef type v] map. Nulls are not permitted
   * @param entries to be added to [v.name] map
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  [builderInitAccess v] final [builderReturnType type] [v.names.init]([if v.multimapType][guava].collect.Multimap[else]java.util.Map[/if]<[gE], ? extends [wV]> entries) {
    [defineOrResetBuildingField v false]
    return [v.names.putAll](entries);
  }
          [/if]
        [/if]

  /**
   * Put all mappings from specified map as entries to [sourceDocRef type v] map. Nulls are not permitted
   * @param entries to be added to [v.name] map
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  [builderInitAccess v] final [builderReturnType type] [v.names.putAll]([if v.multimapType][guava].collect.Multimap[else]java.util.Map[/if]<[gE], ? extends [wV]> entries) {
    [if v.generateJdkOnly]
    for (java.util.Map.Entry<[gE], ? extends [wV]> entry : entries.entrySet()) {
      [v.name]Builder.put(
          [requireNonNull type](entry.getKey(), "Key cannot be null"),
          [requireNonNull type](entry.getValue(), "Value cannot be null"));
    }
    [else]
    [v.name]Builder.putAll(entries);
    [/if]
    [builderReturnThis type]
  }
    [/for]
  [else if v.arrayType]

  /**
   * Initializes value for [sourceDocRef type v].
  [if v.generateDefault]
   * <p><em>If not set, this attribute will have default value as defined by [sourceDocRef type v].</em>
  [/if]
   * @param elements elements for [v.name]
   * @return {@code this} builder for chained invocation
   */
  [varargsSafety v]
  [deprecation v]
  [builderInitAccess v] final [builderReturnType type] [v.names.init]([v.elementType]... elements) {
    [checkNotIsSet v]
    this.[v.name] = elements.clone();
    [mandatorySetInBuilder v]
    [builderReturnThis type]
  }
  [else]

  /**
   * Initializes value for [sourceDocRef type v].
  [if v.generateDefault]
   * <p><em>If not set, this attribute will have default value returned by initializer of [sourceDocRef type v].</em>
  [/if]
   * @param [v.name] value for [v.name][if v.nullable], can be {@code null}[/if]
   * @return {@code this} builder for chained invocation
   */
  [deprecation v]
  [builderInitAccess v] final [builderReturnType type] [v.names.init]([v.atNullability][v.type] [v.name]) {
    [checkNotIsSet v]
    [if v.primitive or v.nullable]
    this.[v.name] = [v.name];
    [else]
    this.[v.name] = [requireNonNull type]([v.name]);
    [/if]
    [nondefaultSetInBuilder v]
    [mandatorySetInBuilder v]
    [builderReturnThis type]
  }
  [/if]
  [/for]
[if type.generateClearBuilder]
  /**
   * Clear builder to initial state.
   */
  public [builderReturnType type] [type.names.clear]() {
    [for l in positions.longs]
    [disambiguateField type 'initBits'][emptyIfZero l.index] = [literal.hex l.occupation];
    [/for]
    [for l in nondefaultsPositions.longs]
    [disambiguateField type 'optBits'][emptyIfZero l.index] = 0;
    [/for]
    [for v in setters]
    [defineOrResetBuildingField v false]
    [/for]
    [builderReturnThis type]
  }
[/if]
  /**
  [if type.kind.isFactory]
   * Invokes {@code [type.factoryOf](..)} using collected parameters and returning its result
   * @return result of type {@code [type.typeValue]}
  [else]
   * Builds new {@link [type.typeValue] [type.typeValue.simple]}.
   * @return immutable instance of [type.name]
  [/if]
   * @throws [type.throwForInvalidImmutableState] if any required attributes are missing
   */
  public [if type.constitution.isSimple][type.typeValue.simple][else][type.typeValue][/if] [type.names.build]()
      throws [type.throwForInvalidImmutableState][for t in type.throwing], [t][/for] {
    [builderBody positions type]checkRequiredAttributes()[/builderBody]
  }
  [if type.isGenerateBuildOrThrow]
  [if classpath.isJava8 or (not type.generateJdkOnly)]

  /**
  [if type.kind.isFactory]
   * Invokes {@code [type.factoryOf](..)} using collected parameters and returning its result
   * @return result of type {@code [type.typeValue]}
  [else]
   * Builds new {@link [type.typeValue] [type.typeValue.simple]}.
   * @return immutable instance of [type.name]
  [/if]
   * @throws the supplied exception {@code T} if any required attributes are missing
   */
  public <T extends Exception> [if type.constitution.isSimple][type.typeValue.simple][else][type.typeValue][/if] [type.names.buildOrThrow]([functionClass]<String, T> exceptionSupplier)
      throws T[for t in type.throwing], [t][/for] {
    [builderBody positions type]checkRequiredAttributesOrThrow(exceptionSupplier)[/builderBody]
  }
  [/if]
  [/if]
  [for p in nondefaults, BitPosition pos = nondefaultsPositions p]

  private boolean [p.names.isSet]() {
    return ([disambiguateField type 'optBits'][emptyIfZero pos.index] & OPT_BIT_[toConstant p.name]) != 0;
  }
  [/for]
  [for m in mandatories, BitPosition pos = positions m]

  private boolean [m.names.isSet]() {
    return ([disambiguateField type 'initBits'][emptyIfZero pos.index] & INIT_BIT_[toConstant m.name]) == 0;
  }
  [/for]
  [if type.useStrictBuilder and (nondefaultsPositions.longs or positions.longs)]

  private void checkNotIsSet(boolean isSet, String name) {
    if (isSet) throw new IllegalStateException("Builder of [type.name] is strict, attribute is already set: ".concat(name));
  }
  [/if]
  [if positions.longs]

  private void checkRequiredAttributes() throws [type.throwForInvalidImmutableState] {
    [checkRequiredOrThrow type positions]new [type.throwForInvalidImmutableState][/checkRequiredOrThrow]
  }
  [if type.isGenerateBuildOrThrow]
    [if classpath.isJava8 or (not type.generateJdkOnly)]

  private <T extends Exception> void checkRequiredAttributesOrThrow([functionClass]<String, T> exceptionSupplier) throws T {
    [checkRequiredOrThrow type positions]exceptionSupplier.apply[/checkRequiredOrThrow]
  }
    [/if]
  [/if]
  private String formatRequiredAttributesMessage() {
    java.util.List<String> attributes = [if type.generateJdkOnly]new java.util.ArrayList<String>()[else][guava].collect.Lists.newArrayList()[/if];
    [for m in mandatories]
    if (![m.names.isSet]()) attributes.add("[m.name]");
    [/for]
    return "Cannot build [type.name], some of required attributes are not set " + attributes;
  }
  [/if]
[if type.constitution.hasImmutableInBuilder]
  [generateImmutable type false]
[/if]
[if topLevel and type.generateJdkOnly]
  [objectsUtility type]
[/if]
[if topLevel and (type.generateJdkOnly and type.useCollectionUtility)]
  [collectionUtility type]
[/if]
}
[/for]
[/template]

[template builderBody LongPositions positions Type type String attributeChecker][output.linesShortable]
[if positions.longs]
[attributeChecker];
[/if]
[if type.kind.isFactory]
[returnFactoryBuild type]
[else if type.useSingleton and (not type.settableAttributes)]
return [type.factoryInstance.relative]();
[else if type.generateBuilderUseCopyConstructor]
[generateReturnBuilderConstructed type]
[else]
return [validated type true]new [type.typeImmutable.relative](this)[/validated];
[/if]
[/output.linesShortable][/template]

[template checkRequiredOrThrow Type type LongPositions positions String throwSupplier]
if ([for l in positions.longs][if not for.first]
        || [/if][disambiguateField type 'initBits'][emptyIfZero l.index] != 0[/for]) {
  throw [throwSupplier](formatRequiredAttributesMessage());
}
[/template]

[template buildFromAttribute Attribute v]
  [if v.collectionType]
[v.names.addAll](instance.[v.names.get]());
  [else if v.mapType]
[v.names.putAll](instance.[v.names.get]());
  [else if v.optionalType]
[v.type] [v.name]Optional = instance.[v.names.get]();
if ([v.name]Optional.isPresent()) {
  [v.names.init]([v.name]Optional);
}
  [else if v.nullable]
[v.atNullabilityLocal][v.type] [v.name]Value = instance.[v.names.get]();
if ([v.name]Value != null) {
  [v.names.init]([v.name]Value);
}
  [else]
[v.names.init](instance.[v.names.get]());
  [/if]
[/template]

[template returnFactoryBuild Type type]
return [type.factoryOf]([output.linesShortable][for v in type.settableAttributes][if not for.first],
    [/if][output.trim]
  [if v.collectionType or v.mapType]
    [immutableCollectionBuild v][v.name]Builder[/immutableCollectionBuild]
  [else]
    [v.name]
  [/if][/output.trim][/for][/output.linesShortable]);
[/template]

[template emptyImmutableInstanceInferred Type type Attribute v][output.trim]
[if v.optionalType]
  [optionalEmpty v]
[else if v.mapType]
  [if v.generateJdkOnly]
    [if v.typeKind.isSortedMap]
      [immutableCollectionCopyOfSafe v false]java.util.Collections.<[v.elementType], [v.secondaryElementType]>emptyMap()[/immutableCollectionCopyOfSafe]
    [else]
      java.util.Collections.emptyMap()
    [/if]
  [else]
    [guava].collect.Immutable[v.rawMapType].of()
  [/if]
[else if v.collectionType]
  [if v.generateJdkOnly]
    [if v.typeKind.isSortedSet]
      [immutableCollectionCopyOfSafe v false]java.util.Collections.<[v.elementType]>emptyList()[/immutableCollectionCopyOfSafe]
    [else]
      java.util.Collections.empty[v.rawCollectionType]()
    [/if]
  [else]
    [guava].collect.Immutable[v.rawCollectionType].of()
  [/if]
[else if v.nullable]
  null
[else]
  null
  [output.error]
    Could not generate constructor. Attribute '[v.name]' does not have default value.
  [/output.error]
[/if]
[/output.trim][/template]

[template generateConstructorNoAttributes Type type Attribute... attributes]
[for v in attributes, n = v.name]
[if v.primitive]
  [if v.boolean]
this.[n] = false;
  [else]
this.[n] = 0;
  [/if]
[else]
this.[n] = null;
[/if]
[/for]
[/template]

[template generateConstructorDefaultAttributes Type type Attribute... attributes]
[for v in attributes if not (v.generateDefault or v.generateDerived), n = v.name]
this.[n] = [emptyImmutableInstanceInferred type v];
[/for]
[for v in attributes if v.generateDefault or v.generateDerived, n = v.name]
[if type.annotationType]
this.[n] = DEFAULT_VALUE_[toConstant v.name];
[else]
  [if type.generateSafeDerived]
this.[n] = [disambiguateField type 'initShim'].[v.names.get]();
  [else if v.primitive or v.nullable]
this.[n] = [invokeSuper v].[v.names.get]();
  [else]
this.[n] = [requireNonNull type]([invokeSuper v].[v.names.get]());
  [/if]
[/if]
[/for]
[/template]

[template generateImmutableMembers Type type]
[for setters = type.settableAttributes, getters = type.implementedAttributes]
[for v in getters]
  private final [v.atNullability][immutableImplementationType v] [v.name];
[/for]
[if type.usePrehashed]
  private final int hashCode;
[/if]
[if type.generateOrdinalValue]
  private final int ordinal;
  private final Domain domain;
[/if]
[if type.useSingleton]

  private [type.typeImmutable.simple]() {[output.collapsible]
    [generateConstructorDefaultAttributes type type.implementedAttributes]
    [generateAfterConstruction type false]
  [/output.collapsible]}
[else if type.generatePrivateNoargConstructor]

  private [type.typeImmutable.simple]() {[output.collapsible]
    [generateConstructorNoAttributes type type.implementedAttributes]
    [generateAfterConstruction type false]
  [/output.collapsible]}
[/if]
[if type.useConstructor and (not type.generateConstructorUseCopyConstructor)]

  private [type.typeImmutable.simple]([output.linesShortable][for v in type.constructorArguments][if not for.first],[/if]
      [v.atNullability][constructorAcceptType v] [v.name][/for][/output.linesShortable]) {
[for v in type.constructorArguments, n = v.name]
  [if v.collectionType or v.mapType]
    this.[n] = [immutableCollectionCopyOf v n];
  [else if v.primitive or v.nullable]
    this.[n] = [n];
  [else]
    this.[n] = [requireNonNull type]([n]);
  [/if]
[/for]
[if type.generateSafeDerived]
  [for v in type.constructorArguments if v.generateDefault]
    [disambiguateField type 'initShim'].[v.names.init]([v.name]);
  [/for]
[/if]
    [generateConstructorDefaultAttributes type type.constructorOmited]
    [generateAfterConstruction type false]
  }
[/if]
[if type.generateBuilderConstructor]

  private [type.typeImmutable.simple]([type.typeBuilderImpl.relative] builder) {
[for v in getters if not v.generateDerived, n = v.name]
  [if v.collectionType or v.mapType]
    this.[n] = [immutableCollectionBuild v]builder.[n]Builder[/immutableCollectionBuild];
  [else if not v.generateDefault]
    this.[n] = builder.[n];
  [/if]
[/for]
[-- Generate default values comes after required values]
[if type.generateSafeDerived]
  [for v in getters if v.generateDefault, n = v.name]
    if ([if v.primitive]builder.[n]IsSet()[else]builder.[n] != null[/if]) {
      [disambiguateField type 'initShim'].[v.names.init](builder.[n]);
    }
  [/for]
[/if]
[for v in getters, n = v.name]
[if v.generateDefault]
  [if type.generateSafeDerived]
    this.[n] = [disambiguateField type 'initShim'].[v.names.get]();
  [else if v.primitive]
    this.[n] = builder.[n]IsSet()
        ? builder.[n]
      [if type.annotationType]
        : DEFAULT_VALUE_[toConstant v.name];
      [else]
        : [invokeSuper v].[v.names.get]();
      [/if]
  [else]
    this.[n] = builder.[n] != null
        ? builder.[n]
      [if type.annotationType]
        : DEFAULT_VALUE_[toConstant v.name];
      [else if v.nullable]
        : [invokeSuper v].[v.names.get]();
      [else]
        : [requireNonNull type]([invokeSuper v].[v.names.get]());
      [/if]
  [/if]
[/if]
[/for]
    [generateDerivedConstruction type]
    [generateAfterConstruction type true]
  }
[/if]
[if type.useCopyMethods]

  private [type.typeImmutable.simple]([output.linesShortable]
      [if type.synthCopyConstructor][type.typeImmutable.simple] original,
      [/if][for v in getters if not v.generateDerived][if not for.first],
      [/if][v.atNullability][immutableImplementationType v] [v.name][/for][/output.linesShortable]) {
  [for v in getters if not v.generateDerived]
    this.[v.name] = [v.name];
  [/for]
  [if type.generateSafeDerived]
  [for v in getters if v.generateDefault]
    [disambiguateField type 'initShim'].[v.names.init]([v.name]);
  [/for]
  [/if]
    [generateDerivedConstruction type]
    [generateAfterConstruction type false]
  }
[/if]
[if type.generateSafeDerived]
  [generateSafeDerivedShim type]
[/if]
  [generateAccessorMethods type]
  [generateCopyMethods type]
  [generateObjectUtilityMethods type]
  [generateJacksonMapped type]
[/for]
[/template]

[template generateDerivedConstruction Type type]
[for v in type.implementedAttributes if v.generateDerived]
  [if type.generateSafeDerived]
this.[v.name] = [disambiguateField type 'initShim'].[v.names.get]();
  [else if v.primitive or v.nullable]
this.[v.name] = [invokeSuper v].[v.names.get]();
  [else]
this.[v.name] = [requireNonNull type]([invokeSuper v].[v.names.get]());
  [/if]
[/for]
[/template]

[template generateSafeDerivedShim Type type]
[for deriveds = v for v in type.implementedAttributes if v.generateDefault or v.generateDerived]

private static final int STAGE_INITIALIZING = -1;
private static final int STAGE_UNINITIALIZED = 0;
private static final int STAGE_INITIALIZED = 1;
[-- would it remain thread safe if remove volatile? --]
private volatile InitShim [disambiguateField type 'initShim'] = new InitShim();

private final class InitShim {
[for v in deriveds]
  [let stage][disambiguateField type][v.name]Stage[/disambiguateField][/let]
  [let invokeSuperGet][disambiguateAccessor type][v.names.get]Initialize[/disambiguateAccessor][/let]
  private [v.type] [v.name];
  private byte [stage];

  [v.type] [v.names.get]() {
    if ([stage] == STAGE_INITIALIZING) throw new [type.throwForInvalidImmutableState](formatInitCycleMessage());
    if ([stage] == STAGE_UNINITIALIZED) {
      [stage] = STAGE_INITIALIZING;
        [if v.primitive or v.nullable]
      this.[v.name] = [if v.defaultInterface][invokeSuperGet][else][invokeSuperQualified v].[v.names.get][/if]();
        [else]
      this.[v.name] = [requireNonNull type]([if v.defaultInterface][invokeSuperGet][else][invokeSuperQualified v].[v.names.get][/if]());
        [/if]
      [stage] = STAGE_INITIALIZED;
    }
    return [v.name];
  }
  [if v.generateDefault]

  [v.type] [v.names.init]([v.type] value) {
    this.[v.name] = value;
    [stage] = STAGE_INITIALIZED;
    return value;
  }
  [/if]
[/for]

  private String formatInitCycleMessage() {
    java.util.ArrayList<String> attributes = [if type.generateJdkOnly]new java.util.ArrayList<String>()[else][guava].collect.Lists.newArrayList()[/if];
    [for v in deriveds]
    [let stage][disambiguateField type][v.name]Stage[/disambiguateField][/let]
    if ([stage] == STAGE_INITIALIZING) attributes.add("[v.name]");
    [/for]
    return "Cannot build [type.name], attribute initializers form cycle" + attributes;
  }
}

[for v in deriveds if v.defaultInterface]
[let invokeSuperGet][disambiguateAccessor type][v.names.get]Initialize[/disambiguateAccessor][/let]
private [v.type] [invokeSuperGet]() {
  return [invokeSuper v].[v.names.get]();
}
[/for]
[/for]
[/template]

[template constructorAcceptType Attribute a][output.trim]
[if a.typeKind.isMultimapKind]
  [guava].collect.Multimap<[a.consumedElementType], ? extends [a.secondaryElementType]>
[else if a.typeKind.isMapKind]
  java.util.Map<[a.consumedElementType], ? extends [a.secondaryElementType]>
[else if a.typeKind.isCollectionKind]
  Iterable<[a.consumedElementType]>
[else]
  [a.type]
[/if]
[/output.trim][/template]

[template generateJacksonMapped Type type]
[if type.generateJacksonMapped]
[if type.implementedAttributes]

/**
 * Simple representation of this value type suitable Jackson binding
 * @deprecated Do not use this type directly, it exists only for <em>Jackson</em>-binding infrastructure
 */
@Deprecated
@com.fasterxml.jackson.databind.annotation.JsonDeserialize
static final class JsonPojo [extendsImplements type]
[for v in type.implementedAttributes]
  private [atNullable][v.type] [v.name];
[/for]

[for v in type.implementedAttributes]
  @Override
  [if v.isPublic]public [/if][v.atNullability][v.type] [v.names.get]() {
    return [v.name];
  }
  public void [v.names.jsonSet]([v.atNullability][v.type] [v.name]) {
    this.[v.name] = [v.name];
  }
[/for]
}

[/if]

/**
 * @param json JSON-bindable data structure
 * @return immutable value type
 * @deprecated Do not use this method directly, it exists only for <em>Jackson</em>-binding infrastructure
 */
@Deprecated
@com.fasterxml.jackson.annotation.JsonCreator
static [type.typeValue.relative] fromJson([if type.implementedAttributes]JsonPojo json[else]java.util.Map<String, Object> json[/if]) {
[if type.useBuilder]
  [type.typeBuilder.relative] builder = [type.factoryBuilder.relative]();
  [if type.implementedAttributes]
  builder = builder.from(json);
  [else]
  [for v in type.settableAttributes]
  if (json.[v.name] != null) {
      [if v.collectionType]
    builder.[v.names.addAll](json.[v.name]);
      [else if v.mapType]
    builder.[v.names.putAll](json.[v.name]);
      [else]
    builder.[v.names.init](json.[v.name]);
      [/if]
  }
  [/for]
  [/if]
  return builder.[type.names.build]();
[else if type.useSingletonOnly]
  return [type.factoryInstance.relative]();
[else]
    [if type.useConstructor]
  [type.typeValue.relative] instance = [type.factoryOf.relative]([for v in type.constructorArguments][if not for.first], [/if]json.[v.name][/for]);
    [else if type.useSingleton]
  [type.typeValue.relative] instance = [type.factoryInstance.relative]();
    [else]
  [output.error]Cannot generate code when there are no builder, constructor or singleton available[/output.error]
    [/if]
  [for o in type.withSettableAfterConstruction]
  if (json.[o.name] != null) {
    instance = instance.[o.names.with](json.[o.name]);
  }
  [/for]
  return instance;
[/if]
}
[/if]
[/template]

[template generateAccessorMethods Type type]
[if type.annotationType]

/** {@inheritDoc} */
@Override
public Class<? extends java.lang.annotation.Annotation> annotationType() {
  return [type.typeAbstract].class;
}
[/if]
  [for v in type.implementedAttributes]

/**
  [if v.docComment]
[for d in v.docComment]
 *[d][-- no space before doc line!]
[/for]
  [else]
[if v.arrayType]
 * @return cloned {@code [v.name]} array
[else if v.generateDerived]
 * @return computed at construction value of {@code [v.name]} attribute
[else]
 * @return value of {@code [v.name]} attribute
[/if]
  [/if]
 */
[for a in v.annotations]
[a]
[/for]
[deprecation v]
@Override
[if v.isPublic]public [/if][v.atNullability][immutableImplementationType v] [v.names.get]() {
[if type.generateSafeDerived and (v.generateDerived or v.generateDefault)]
  return [disambiguateField type 'initShim'] != null
      ? [disambiguateField type 'initShim'].[v.names.get]()
      : [v.name];
[else if v.arrayType]
  return [v.name].clone();
[else]
  return [v.name];
[/if]
}
  [/for]
  [if type.generateOrdinalValue]

/** {@inheritDoc} */
@Override
public int ordinal() {
  return ordinal;
}
  [/if]
[/template]

[template generateObjectUtilityMethods Type type]
[let equalToType][if type.annotationType][type.typeAbstract.relative][else][type.typeImmutable.simple][/if][/let]
[for getters = type.equivalenceAttributes]
[if type.useReferenceEquality or (not type.equalToDefined)]

/**
[if type.annotationType]
 * This instance is equal to any implementation of {@link [type.typeAbstract.relative]} with equal attribute values.
[else]
 * This instance is equal to instances of {@code [type.typeImmutable.simple]} with equal attribute values.
[/if]
[if type.useReferenceEquality]
 * As instances of {@code [type.typeImmutable.simple]} class are interned, {@code equals} method is implemented
 * as efficient reference equality check.
[/if]
 * @return {@code true} if {@code this} is equal to {@code another} instance
 */
@Override
public boolean equals([atNullable]Object another) {
  [if type.useReferenceEquality]
  return this == another;
  [else]
  if (this == another) return true;
  return another instanceof [equalToType]
      && equalTo(([equalToType]) another);
  [/if]
}
[/if]
[if type.useEqualTo]

private boolean equalTo([equalToType] another) {
  [if type.equalToDefined]
  return super.equals(another);
  [else]
  return [if not getters]true[/if][for v in getters][if not for.first]
      && [/if][equalsAttribute v type.annotationType][/for];
  [/if]
}
[/if]
[let computeHashCodeBody]
[let h][disambiguateField type 'h'][/let]
[if type.annotationType]
  int [h] = 0;
[for v in getters]
[if v.arrayType]
  [h] += 127 * "[v.name]".hashCode() ^ java.util.Arrays.hashCode([v.name]);
[else if v.primitive]
  [h] += 127 * "[v.name]".hashCode() ^ [primitiveHashCode v];
[else]
  [h] += 127 * "[v.name]".hashCode() ^ [v.name].hashCode();
[/if]
[/for]
  return [h];
[else if getters.isEmpty]
  return [type.hashCode];
[else]
  int [h] = 31;
[for v in getters]
[if v.nullable]
  [h] = [h] * 17 + [if type.generateJdkOnly][objectsUtilRef type]hashCode[else][guava].base.Objects.hashCode[/if]([v.name]);
[else if v.arrayType]
  [h] = [h] * 17 + java.util.Arrays.hashCode([v.name]);
[else if v.primitive]
  [h] = [h] * 17 + [primitiveHashCode v];
[else]
  [h] = [h] * 17 + [v.name].hashCode();
[/if]
[/for]
  return [h];
[/if]
[/let]
[if type.hashCodeDefined]
  [if type.usePrehashed]

/**
 * Returns precomputed on construction hash code from super implementation {@code super.hashCode()}.
 * @return hashCode value
 */
@Override
public int hashCode() {
  return hashCode;
}
  [/if]
[else]

/**
[if not getters]
 * Returns constant hash code value.
[else if type.usePrehashed]
 * Returns precomputed on construction hash code from attributes: [for a in getters][if not for.first], [/if]{@code [a.name]}[/for].
[else]
 * Computes hash code from attributes: [for a in getters][if not for.first], [/if]{@code [a.name]}[/for].
[/if]
 * @return hashCode value
 */
@Override
public int hashCode() {
  [if type.usePrehashed]
  return hashCode;
  [else]
[computeHashCodeBody]
  [/if]
}
  [if type.usePrehashed]

private int [disambiguateAccessor type 'computeHashCode']() {
[computeHashCodeBody]
}
  [/if]
[/if]
[/for]
[generateToString type]
[/template]

[template generateToString Type type]
[if not type.toStringDefined]

/**
 * Prints immutable value {@code [type.name]...} with attribute values,
 * excluding any non-generated and auxiliary attributes.
 * @return string representation of value
 */
@Override
public String toString() {
[if not type.equivalenceAttributes]
  [if type.annotationType]
  return "@[type.name]";
  [else]
  return "[type.name]{}";
  [/if]
[else if type.generateJdkOnly]
  [if type.annotationType]
  return "@[type.name]("
  [else]
  return "[type.name]{"
  [/if]
  [for v in type.equivalenceAttributes]
  [if v.arrayType]
      + "[if not for.first], [/if][v.name]=" + java.util.Arrays.toString([v.name])
  [else]
      + "[if not for.first], [/if][v.name]=" + [v.name]
  [/if]
  [/for]
      + [if type.annotationType]")"[else]"}"[/if];
[else]
  return [type.typeMoreObjects].toStringHelper("[if type.annotationType]@[/if][type.name]")
  [for v in type.equivalenceAttributes]
  [if v.arrayType]
      .add("[v.name]", java.util.Arrays.toString([v.name]))
  [else]
      .add("[v.name]", [v.name])
  [/if]
  [/for]
      .toString();
  [/if]
}
[/if]
[/template]

[template generateAfterConstruction Type type Boolean usingBuilder]
  [if type.usePrehashed]
this.hashCode = [if type.hashCodeDefined]super.hashCode()[else][disambiguateAccessor type 'computeHashCode']()[/if];
  [/if]
  [if type.generateOrdinalValue][-- Assigning dummy ordinal value to be changed on interning --]
this.ordinal = 0;
    [if usingBuilder]
this.domain = builder.domain;
    [else]
[-- Default static ordinal domain --]
this.domain = Domain.get();
    [/if]
  [/if]
  [if type.generateSafeDerived]
this.[disambiguateField type 'initShim'] = null;
  [/if]
[/template]

[template generateReturnCopyContextual Type type Attribute modified]
return [validated type false]new [type.typeImmutable.simple]([output.linesShortable]
    [if type.synthCopyConstructor]this,
    [/if][for a in type.implementedAttributes if not a.generateDerived][if not for.first],
    [/if][if a.name eq modified.name]newValue[else]this.[a.name][/if][/for][/output.linesShortable])[/validated];
[/template]

[template generateReturnBuilderConstructed Type type]
return [validated type true]new [type.typeImmutable.relative]([output.linesShortable]
    [if type.synthCopyConstructor]null,
    [/if][for v in type.implementedAttributes if not v.generateDerived][if not for.first],
    [/if][output.trim]
    [if v.collectionType or v.mapType]
      [immutableCollectionBuild v][v.name]Builder[/immutableCollectionBuild]
    [else]
      [v.name]
    [/if]
        [/output.trim][/for][/output.linesShortable])[/validated];
[/template]

[template generateCopyMethods Type type]
[if type.useCopyMethods]
  [for v in type.settableAttributes]
    [if v.arrayType]

/**
 * Copy current immutable object with elements that replace content of [sourceDocRef type v].
 * Array is cloned before saved as the attribute value.
 * @param elements elements for [v.name], not null
 * @return modified copy of {@code this} object
 */
[varargsSafety v]
[deprecation v]
public final [type.typeImmutable.simple] [v.names.with]([v.elementType]... elements) {
  [immutableImplementationType v] newValue = elements.clone();
  [generateReturnCopyContextual type v]
}
    [else if v.collectionType]

/**
 * Copy current immutable object with elements that replace content of [sourceDocRef type v].
 * @param elements elements to set
 * @return modified copy of {@code this} object
 */
[varargsSafety v]
[deprecation v]
public final [type.typeImmutable.simple] [v.names.with]([v.unwrappedElementType]... elements) {
  [if v.generateJdkOnly and v.primitiveElement]
  java.util.ArrayList<[v.wrappedElementType]> wrappedList = new java.util.ArrayList<[v.wrappedElementType]>(elements.length);
  for ([v.unwrappedElementType] element : elements) {
    wrappedList.add(element);
  }
  [immutableImplementationType v] newValue = [immutableCollectionCopyOfSafe v false]wrappedList[/immutableCollectionCopyOfSafe];
  [else]
  [immutableImplementationType v] newValue = [immutableCollectionCopyOf v][if v.wrapArrayToIterable][arrayAsList v 'elements'][else]elements[/if][/immutableCollectionCopyOf];
  [/if]
  [generateReturnCopyContextual type v]
}

/**
 * Copy current immutable object with elements that replace content of [sourceDocRef type v].
 * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
 * @param elements iterable of [v.name] elements to set
 * @return modified copy of {@code this} object
 */
[deprecation v]
public final [type.typeImmutable.simple] [v.names.with](Iterable<[v.consumedElementType]> elements) {
  if (this.[v.name] == elements) return this;
  [immutableImplementationType v] newValue = [immutableCollectionCopyOf v 'elements'];
  [generateReturnCopyContextual type v]
}
    [else if v.optionalType]

/**
 * Copy current immutable object by setting present value for optional [sourceDocRef type v].
 * @param value value for [v.name][if v.optionalAcceptNullable], {@code null} is accepted as {@code [optionalEmpty v]}[/if]
 * @return modified copy of {@code this} object
 */
[deprecation v]
public final [type.typeImmutable.simple] [v.names.with]([atNullableAccept v][v.unwrappedElementType] value) {
  [immutableImplementationType v] newValue = [optionalOf v](value);
  [generateReturnCopyContextual type v]
}

/**
 * Copy current immutable object by setting optional value for [sourceDocRef type v].
 * Shallow reference equality check on optional value is used to prevent copying of the same value by returning {@code this}.
 * @param optional value for [v.name]
 * @return modified copy of {@code this} object
 */
[deprecation v]
public final [type.typeImmutable.simple] [v.names.with]([v.rawType][if not v.jdkSpecializedOptional]<[v.wrappedElementType]>[/if] optional) {
  if (this.[v.name] == optional) return this;
  [immutableImplementationType v] newValue = [requireNonNull type](optional);
  [generateReturnCopyContextual type v]
}
    [else if v.mapType]
    [for gE = v.consumedElementType, uK = v.unwrappedElementType, wK = v.wrappedElementType, uV = v.unwrappedSecondaryElementType, wV = v.wrappedSecondaryElementType]

/**
 * Copy current immutable object by replacing [sourceDocRef type v] map with specified map.
 * Nulls are not permitted as keys or values.
 * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
 * @param entries to be added to [v.name] map
 * @return modified copy of {@code this} object
 */
[deprecation v]
public final [type.typeImmutable.simple] [v.names.with]([if v.multimapType][guava].collect.Multimap[else]java.util.Map[/if]<[gE], ? extends [wV]> entries) {
  if (this.[v.name] == entries) return this;
  [immutableImplementationType v] newValue = [immutableCollectionCopyOf v 'entries'];
  [generateReturnCopyContextual type v]
}
    [/for]
    [else]

/**
 * Copy current immutable object by setting value for [sourceDocRef type v].
 [if v.primitive and (not v.floatType)]
 * Value equality check is used to prevent copying of the same value by returning {@code this}.
 [else if not v.primitive]
 * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
 [/if]
 * @param value new value for [v.name][if v.nullable], can be {@code null}[/if]
 * @return modified copy of the {@code this} object
 */
[deprecation v]
public final [type.typeImmutable.simple] [v.names.with]([v.atNullability][v.type] value) {
    [if not v.floatType]
  if (this.[v.name] == value) return this;
    [/if]
    [if v.nullable or v.primitive]
  [v.atNullabilityLocal][immutableImplementationType v] newValue = value;
    [else]
  [immutableImplementationType v] newValue = [requireNonNull type](value);
    [/if]
  [generateReturnCopyContextual type v]
}
    [/if]
  [/for]
[/if]
[/template]

[template defaultAnnotationValues Type type]
[for defaults = type.defaultAttributes]
[if defaults]
[for a in defaults]
private static final [a.type] DEFAULT_VALUE_[toConstant a.name];
[/for]

static {
  try {
  [for a in defaults]
    DEFAULT_VALUE_[toConstant a.name] =
        cast([type.typeAbstract.relative].class.getDeclaredMethod("[a.name]").getDefaultValue());
  [/for]
  } catch(Exception e) {
    throw new ExceptionInInitializerError(e);
  }
}

@SuppressWarnings("unchecked")
private static <T> T cast(Object object) {
  return (T) object;
}
[/if]
[/for]
[/template]

[template forwardingEnclosingFactoryMethods Type type]
  [if type.constitution.isImplementationHidden]
    [if type.useSingleton]

/**
 * Returns default immutable singleton value of [type.name]
 * @return immutable instance of [type.name]
 */
public static [type.typeValue.relative] [type.factoryInstance.simple]() {
  return [type.typeImmutable.relative].[type.names.instance]();
}
    [/if]
    [if type.useConstructor]
      [if type.requiresAlternativeStrictConstructor]

/**
 * Construct new immutable {@code [type.name]} instance.
[for v in type.constructorArguments]
 * @param [v.name] value for {@code [v.name]}
[/for]
 * @return immutable [type.name] instance
 */
public static [type.typeValue.relative] [type.factoryOf.simple]([for v in type.constructorArguments][if not for.first], [/if][v.atNullability][v.type] [v.name][/for]) {
  return [type.factoryOf.simple]([for v in type.constructorArguments][if not for.first], [/if][if v.requiresAlternativeStrictConstructor]([constructorAcceptType v]) [/if][v.name][/for]);
}
      [/if]

/**
 * Construct new immutable {@code [type.name]} instance.
[for v in type.constructorArguments]
 * @param [v.name] value for {@code [v.name]}
[/for]
 * @return immutable [type.name] instance
 */
public static [type.typeValue.relative] [type.factoryOf.simple]([for v in type.constructorArguments][if not for.first], [/if][v.atNullability][constructorAcceptType v] [v.name][/for]) {
  return [type.typeImmutable.relative].[type.names.of]([for v in type.constructorArguments][if not for.first], [/if][v.name][/for]);
}
    [/if]
  [/if]
[/template]

[template immutableImplementationType Attribute v][output.trim]
[if v.generateJdkOnly][-- for now jdk only will be the same --]
  [v.type]
[else if v.generateOrdinalValueSet]
  org.immutables.ordinal.ImmutableOrdinalSet<[v.elementType]>
[else if v.generateSortedSet]
  [guava].collect.ImmutableSortedSet<[v.elementType]>
[else if v.collectionType]
  [guava].collect.Immutable[v.rawCollectionType]<[v.elementType]>
[else if v.generateSortedMap]
  [guava].collect.ImmutableSortedMap<[v.elementType], [v.secondaryElementType]>
[else if v.mapType]
  [guava].collect.Immutable[v.rawMapType]<[v.elementType], [v.secondaryElementType]>
[else]
  [v.type]
[/if]
[/output.trim][/template]

[template immutableCollectionBuild Attribute a String expression][output.trim]
[if a.generateJdkOnly]
  [if a.generateSortedSet]
    createUnmodifiableSortedSet([a.hasReverseOrder], createSafeList([expression]))
  [else if a.generateEnumSet]
    createUnmodifiableEnumSet([expression])
  [else if a.generateOrdinalValueSet]
    [output.error]Not implemented generate OrdinalValue set for JDK only[/output.error]
  [else if a.listType]
    createUnmodifiableList(true, [expression])
  [else if a.setType]
    createUnmodifiableSet([expression])
  [else if a.generateEnumMap]
    createUnmodifiableEnumMap(false, [expression])
  [else if a.generateSortedMap]
    createUnmodifiableSortedMap([a.hasReverseOrder], false, [expression])
  [else if a.mapType]
    createUnmodifiableMap(false, [expression])
  [/if]
[else]
  [if a.generateOrdinalValueSet or (a.generateEnumSet or a.generateEnumMap)]
    [immutableCollectionCopyOf a][expression].build()[/immutableCollectionCopyOf]
  [else]
    [expression].build()
  [/if]
[/if]
[/output.trim][/template]

[template immutableCollectionCopyOf Attribute a String expression][immutableCollectionCopyOfSafe a true expression][/template]

[template immutableCollectionCopyOfSafe Attribute a Boolean safe String expression][output.trim]
[if a.generateJdkOnly]
[let safeList][if safe]createSafeList([expression])[else][expression][/if][/let]
  [if a.generateSortedSet]
    createUnmodifiableSortedSet([a.hasReverseOrder], [safeList])
  [else if a.generateEnumSet]
    createUnmodifiableEnumSet([expression])
  [else if a.generateOrdinalValueSet]
    [output.error]Not implemented generate OrdinalValue set for JDK only[/output.error]
  [else if a.listType]
    createUnmodifiableList(false, [safeList])
  [else if a.setType]
    createUnmodifiableSet([safeList])
  [else if a.generateEnumMap]
    createUnmodifiableEnumMap([safe], [expression])
  [else if a.generateSortedMap]
    createUnmodifiableSortedMap([a.hasReverseOrder], [safe], [expression])
  [else if a.mapType]
    createUnmodifiableMap([safe], [expression])
  [else]
    [expression]
  [/if]
[else]
  [if a.generateSortedSet]
    [guava].collect.ImmutableSortedSet.copyOf(
      [if a.hasNaturalOrder]
        [guava].collect.Ordering.<[a.elementType]>natural(),
      [else]
        [guava].collect.Ordering.<[a.elementType]>natural().reverse(),
      [/if]
        [expression])
  [else if a.generateEnumSet]
    [guava].collect.Sets.immutableEnumSet([expression])
  [else if a.generateOrdinalValueSet]
    org.immutables.ordinal.ImmutableOrdinalSet.copyOf([expression])
  [else if a.collectionType]
    [guava].collect.Immutable[a.rawCollectionType].copyOf([expression])
  [else if a.generateSortedMap]
    [guava].collect.ImmutableSortedMap.copyOf([expression],
    [if a.hasNaturalOrder]
        [guava].collect.Ordering.<[a.elementType]>natural()
    [else]
        [guava].collect.Ordering.<[a.elementType]>natural().reverse()
    [/if])
  [else if a.generateEnumMap]
    [guava].collect.Maps.immutableEnumMap([expression])
  [else if a.mapType]
    [guava].collect.Immutable[a.rawMapType].copyOf([expression])
  [else]
    [expression]
  [/if]
[/if]
[/output.trim][/template]

[template public equalsAttribute Attribute a Boolean useAccessor][output.trim]
[let getOther]another.[if useAccessor][a.names.get]()[else][a.name][/if][/let]
[if a.float]
  Float.floatToIntBits([a.name]) == Float.floatToIntBits([getOther])
[else if a.double]
  Double.doubleToLongBits([a.name]) == Double.doubleToLongBits([getOther])
[else if a.primitive]
  [a.name] == [getOther]
[else if a.arrayType]
  java.util.Arrays.equals([a.name], [getOther])
[else if a.nullable]
  [if a.generateJdkOnly]
    [objectsUtilRef a.containingType]equals([a.name], [getOther])
  [else]
    [guava].base.Objects.equal([a.name], [getOther])
  [/if]
[else]
  [a.name].equals([getOther])
[/if]
[/output.trim][/template]

[template public arrayAsList Attribute a String expression][output.trim]
[if a.unwrappedElementPrimitiveType]
  [if a.generateJdkOnly]
    [output.error]Template methods 'arrayAsList' could not be used for primitive jdk only conversion[/output.error]
  [else]
    [guava].primitives.[toUpper a.unwrappedElementType]s.asList([expression])
  [/if]
[else]
  java.util.Arrays.asList([expression])
[/if]
[/output.trim][/template]

[template public arrayAsListSecondary Attribute a String expression][output.trim]
[if a.unwrappedSecondaryElementPrimitiveType]
  [if a.generateJdkOnly]
    [output.error]Template methods 'arrayAsList' could not be used for primitive jdk only conversion[/output.error]
  [else]
    [guava].primitives.[toUpper a.unwrappedSecondaryElementType]s.asList([expression])
  [/if]
[else]
  java.util.Arrays.asList([expression])
[/if]
[/output.trim][/template]

[template public primitiveHashCode Attribute v][output.trim]
[if v.int]
  [v.name]
[else if v.generateJdkOnly]
  [if classpath.isJava8 and (not (classpath.available 'android.R'))]
    [v.wrapperType].hashCode([v.name])
  [else if v.long]
    (int) ([v.name] ^ ([v.name] >>> 32))
  [else if v.boolean]
    ([v.name] ? 1231 : 1237)
  [else if v.float]
    Float.floatToIntBits([v.name])
  [else if v.double][-- Microbenchmark showed that it's ok to new Double, probably due escape analysis --]
    new Double([v.name]).hashCode()
  [else]
    (int) [v.name]
  [/if]
[else]
  [guava].primitives.[toUpper v.type]s.hashCode([v.name])
[/if]
[/output.trim][/template]

[template public objectsUtilRef Type type][output.trim]
[if classpath.unavailable 'java.util.Objects']
  [type.topSimple].
[else if classpath.available 'android.R']
  [type.topSimple].
[else]
  java.util.Objects.
[/if]
[/output.trim][/template]

[template public objectsUtility Type type]
[for Boolean haveObjects = classpath.available 'java.util.Objects',
     Boolean haveAndroid = classpath.available 'android.R']
  [if haveAndroid or (not haveObjects)]

private static <T> T requireNonNull(T object) {
  if (object == null) throw new NullPointerException();
  return object;
}
    [if type.useCollectionUtility]

private static <T> T requireNonNull(T object, String message) {
  if (object == null) throw new NullPointerException(message);
  return object;
}
    [/if]
    [if type.useNullSafeUtilities]

private static int hashCode(Object object) {
  return object != null ? object.hashCode() : 0;
}

private static boolean equals(Object left, Object right) {
  return left == right || (left != null && left.equals(right));
}
    [/if]
  [/if]
[/for]
[/template]

[template public collectionUtility Type type]
[if type.useListUtility or (type.useSetUtility or (type.useEnumSetUtility or type.useSortedSetUtility))]

private static <T> java.util.ArrayList<T> createSafeList(Iterable<? extends T> iterable) {
  java.util.ArrayList<T> list = iterable instanceof java.util.Collection<?>
      ? new java.util.ArrayList<T>(((java.util.Collection<?>) iterable).size())
      : new java.util.ArrayList<T>();

  for (T element : iterable) {
    list.add([requireNonNull type](element, "Null in collection attribute is not allowed"));
  }
  return list;
}
[/if]
[if type.useListUtility]

private static <T> java.util.List<T> createUnmodifiableList(boolean clone, java.util.List<T> list) {
  switch(list.size()) {
  case 0: return java.util.Collections.emptyList();
  case 1: return java.util.Collections.singletonList(list.get(0));
  default:
    if (clone) {
      return java.util.Collections.unmodifiableList(new java.util.ArrayList<T>(list));
    } else {
      if (list instanceof java.util.ArrayList<?>) {
        ((java.util.ArrayList<?>) list).trimToSize();
      }
      return java.util.Collections.unmodifiableList(list);
    }
  }
}
[/if]
[if type.useSetUtility]

/** Unmodifiable set constructed from list to avoid rehashing. */
private static <T> java.util.Set<T> createUnmodifiableSet(java.util.List<T> list) {
  switch(list.size()) {
  case 0: return java.util.Collections.emptySet();
  case 1: return java.util.Collections.singleton(list.get(0));
  default:
    java.util.Set<T> set = new java.util.LinkedHashSet<T>(list.size());
    set.addAll(list);
    return java.util.Collections.unmodifiableSet(set);
  }
}
[/if]
[if type.useEnumSetUtility]

private static <T extends Enum<T>> java.util.Set<T> createUnmodifiableEnumSet(Iterable<T> iterable) {
  if (iterable instanceof java.util.EnumSet<?>) {
    return java.util.Collections.unmodifiableSet(java.util.EnumSet.copyOf((java.util.EnumSet<T>) iterable));
  }
  java.util.ArrayList<T> list = createSafeList(iterable);
  switch(list.size()) {
  case 0: return java.util.Collections.emptySet();
  case 1: return java.util.Collections.singleton(list.get(0));
  default: return java.util.Collections.unmodifiableSet(java.util.EnumSet.copyOf(list));
  }
}
[/if]
[if type.useSortedSetUtility]
[let unmodifiableSortedSetInterface][output.trim]
[if classpath.available 'java.lang.FunctionalInterface']
  NavigableSet
[else]
  SortedSet
[/if]
[/output.trim][/let]

private static <T extends Comparable<T>> java.util.[unmodifiableSortedSetInterface]<T> createUnmodifiableSortedSet(boolean reverse, java.util.List<T> list) {
  java.util.TreeSet<T> set = reverse
      ? new java.util.TreeSet<T>(java.util.Collections.reverseOrder())
      : new java.util.TreeSet<T>();
  set.addAll(list);
  return java.util.Collections.unmodifiable[unmodifiableSortedSetInterface](set);
}
[/if]
[if type.useMapUtility]

private static <K, V> java.util.Map<K, V> createUnmodifiableMap(boolean checkNulls, java.util.Map<? extends K, ? extends V> map) {
  java.util.Map<K, V> linkedMap = new java.util.LinkedHashMap<K, V>(map.size());
  linkedMap.putAll(map);
  if (checkNulls) {
    for (java.util.Map.Entry<K, V> e : linkedMap.entrySet()) {
      [requireNonNull type](e.getKey(), "Null key are not allowed in map");
      [requireNonNull type](e.getValue(), "Null values are not allowed in map");
    }
  }
  switch (linkedMap.size()) {
  case 0: return java.util.Collections.emptyMap();
  case 1:
    java.util.Map.Entry<K, V> e = linkedMap.entrySet().iterator().next();
    return java.util.Collections.singletonMap(e.getKey(), e.getValue());
  default: return java.util.Collections.unmodifiableMap(linkedMap);
  }
}
[/if]
[if type.useEnumMapUtility]

private static <K extends Enum<K>, V> java.util.Map<K, V> createUnmodifiableEnumMap(boolean checkNulls, java.util.Map<K, ? extends V> map) {
  java.util.EnumMap<K, V> enumMap = new java.util.EnumMap<K, V>(map);
  if (checkNulls) {
    for (V value : enumMap.values()) {
      [requireNonNull type](value, "Null values are not allowed in map");
    }
  }
  return java.util.Collections.unmodifiableMap(enumMap);
}
[/if]
[if type.useSortedMapUtility]
[let unmodifiableSortedMapInterface][output.trim]
[if classpath.available 'java.lang.FunctionalInterface']
  NavigableMap
[else]
  SortedMap
[/if]
[/output.trim][/let]

private static <K extends Comparable<K>, V> java.util.[unmodifiableSortedMapInterface]<K, V> createUnmodifiableSortedMap(boolean reverse, boolean checkNulls, java.util.Map<? extends K, ? extends V> map) {
  java.util.TreeMap<K, V> sortedMap = reverse
      ? new java.util.TreeMap<K, V>(java.util.Collections.reverseOrder())
      : new java.util.TreeMap<K, V>();
  sortedMap.putAll(map);
  if (checkNulls) {
    for (java.util.Map.Entry<K, V> e : sortedMap.entrySet()) {
      [requireNonNull type](e.getKey(), "Null key are not allowed in map");
      [requireNonNull type](e.getValue(), "Null values are not allowed in map");
    }
  }
  return java.util.Collections.unmodifiable[unmodifiableSortedMapInterface](sortedMap);
}
[/if]
[/template]

[template defineOrResetBuildingField Attribute v Boolean declare]
  [if v.containerType]
    [if v.generateJdkOnly]
      [if v.optionalType]
[if declare]private [v.type] [/if][v.name] = [optionalEmpty v];
      [else if not declare]
[v.name]Builder.clear();
      [else if v.generateEnumMap]
private java.util.EnumMap<[v.wrappedElementType], [v.wrappedSecondaryElementType]> [v.name]Builder = new java.util.EnumMap<[v.wrappedElementType], [v.wrappedSecondaryElementType]>([v.wrappedElementType].class);
      [else if v.mapType]
private java.util.Map<[v.wrappedElementType], [v.wrappedSecondaryElementType]> [v.name]Builder = new java.util.LinkedHashMap<[v.wrappedElementType], [v.wrappedSecondaryElementType]>();
      [else if v.generateEnumSet]
private java.util.EnumSet<[v.elementType]> [v.name]Builder = java.util.EnumSet.noneOf([v.elementType].class);
      [else]
private java.util.ArrayList<[v.elementType]> [v.name]Builder = new java.util.ArrayList<[v.elementType]>();
      [/if]
    [else]
      [if v.generateSortedSet]
[if declare]private [guava].collect.ImmutableSortedSet.Builder<[v.elementType]> [/if][v.name]Builder = [guava].collect.ImmutableSortedSet.[if v.hasNaturalOrder]naturalOrder[else]reverseOrder[/if]();
      [else if v.collectionType]
[if declare]private [guava].collect.Immutable[v.rawCollectionType].Builder<[v.elementType]> [/if][v.name]Builder = [guava].collect.Immutable[v.rawCollectionType].builder();
      [else if v.optionalType]
[if declare]private [v.type] [/if][v.name] = [optionalEmpty v];
      [else if v.generateSortedMap]
[if declare]private [guava].collect.ImmutableSortedMap.Builder<[v.wrappedElementType], [v.wrappedSecondaryElementType]> [/if][v.name]Builder = [guava].collect.ImmutableSortedMap.[if v.hasNaturalOrder]naturalOrder[else]reverseOrder[/if]();
      [else if v.mapType]
[if declare]private [guava].collect.Immutable[v.rawMapType].Builder<[v.wrappedElementType], [v.wrappedSecondaryElementType]> [/if][v.name]Builder = [guava].collect.Immutable[v.rawMapType].builder();
      [/if]
    [/if]
  [else if v.primitive]
    [if declare]
private [v.type] [v.name];
    [else if v.boolean]
[v.name] = false;
    [else]
[v.name] = 0;
    [/if]
  [else]
    [if declare]
private [atNullable][v.type] [v.name];
    [else]
[v.name] = null;
    [/if]
  [/if]
[/template]

[template createBuilderForCollection Type type Attribute a String variableName]
[if a.mapType]
[let mapParams]<[a.wrappedElementType], [a.wrappedSecondaryElementType]>[/let]
  [if type.generateJdkOnly or a.typeKind.isSortedKind]
java.util.Map[mapParams] [variableName] = new java.util.LinkedHashMap[mapParams]();
  [else]
[guava].collect.Immutable[a.typeKind.rawSimpleName].Builder[mapParams] [variableName] = [guava].collect.Immutable[a.typeKind.rawSimpleName].builder();
  [/if]
[else if a.collectionType]
  [if type.generateJdkOnly or a.typeKind.isSortedKind]
java.util.List<[a.elementType]> [variableName] = new java.util.ArrayList<[a.elementType]>();
  [else]
[guava].collect.Immutable[a.typeKind.rawSimpleName].Builder<[a.elementType]> [variableName] = [guava].collect.Immutable[a.typeKind.rawSimpleName].builder();
  [/if]
[/if]
[/template]

[template createBuiltCollection Type type Attribute a String variableName][output.trim]
[if a.mapType or a.collectionType]
  [if type.generateJdkOnly or a.typeKind.isSortedKind]
    [variableName]
  [else]
    [variableName].build()
  [/if]
[else]
  [variableName]
[/if]
[/output.trim][/template]

[template builderReturnThis Type type]
return [if type.innerBuilder.isExtending]([type.typeBuilder]) [/if]this;
[/template]

[template requireNonNull Type type][if type.generateJdkOnly][objectsUtilRef type]requireNonNull[else][guava].base.Preconditions.checkNotNull[/if][/template]

[template builderReturnType Type type][if type.innerBuilder.isExtending][type.typeBuilder][else][type.typeBuilder.simple][/if][/template]

[template validated Type type Boolean qualified String expression][if type.useValidation][if qualified][type.typeImmutable.relative].[/if]validate([expression])[else][expression][/if][/template]

[template builderInitAccess Attribute a][if a.isBuilderParameter]private[else]public[/if][/template]

[template invokeSuper Attribute a][for di = a.defaultInterface][if di][di].[/if][/for]super[/template]

[template invokeSuperQualified Attribute a][a.containingType.typeImmutable.simple].super[/template]

[template sourceDocRef Type t Attribute a][if t.kind.isValue]{@link [t.typeAbstract.relative]#[a.names.get]() [a.names.raw]}[else]{@code [a.names.raw]}[/if][/template]

[template optionalGet Attribute a][if a.jdkSpecializedOptional]getAs[toUpper a.elementType][else]get[/if]()[/template]

[template optionalEmpty Attribute a][a.rawType].[if a.jdkOptional]empty[else]absent[/if]()[/template]

[template optionalOf Attribute a][a.rawType].[if not a.optionalAcceptNullable]of[else if a.jdkOptional]ofNullable[else]fromNullable[/if][/template]

[template atNullableAccept Attribute a][if a.optionalType and a.optionalAcceptNullable][atNullable][/if][/template]

[template atNullable][if classpath.available 'javax.annotation.Nullable']@javax.annotation.Nullable [/if][/template]

[template guava]co['m.google.com']mon[/template][-- this is to hide from jar shading/class relocation in string constants --]

[template disambiguateField Type type String name][name][for v in type.implementedAttributes if v.name eq name]$$[/for][/template]

[template disambiguateAccessor Type type String name][name][for v in type.implementedAttributes if v.names.get eq name]$$[/for][/template]

[template deprecation Attribute a][if a.deprecated]@Deprecated[/if][/template]

[template varargsSafety Attribute a][if a.nonRawElemementType]@SafeVarargs[/if][/template]

[template functionClass][if classpath.isJava8]java.util.function.Function[else][guava].base.Function[/if][/template]
